基础培训  
1. 连接网络  
联网应该是大家熟悉的领域,就不多啰嗦了。Wifi和有线两种,动态分配地址或者静态IP地址配置,框出的部分必
须填写,最后能连上网就行了。
  
 
2. 安装JDK  
环境检查  
首先我们先确认一下自己电脑里是否已经安装了JDK,如果有的话需要先卸载它。 
在添加或删除程序的页面搜索一下就知道。
 
JDK 安装
 
JDK的安装,没有特殊要求,安装1.8版本就可以。首先要去正规的网站下载jdk的安装包。
 
注意选择系统对应的版本。这里就是windows的64位版本。点击执行exe文件,开始进行安装。 
注意jdk和jre的安装位置需要我们额外修改一下,不能使用默认路径。因为program files这个文件夹会使路径包含空
格,许多程序无法正常运行。最保险的是纯英文字母的路径,比如更换到c:\opt\Java\jdk和c:\opt\Java\jre下。
  
环境变量配置
安装完毕后根据安装位置添加环境变量。
控制面板­系统­高级系统设置­高级选项卡­环境变量
  
Win10可以直接通过底栏的搜索按钮搜索环境变量,直接调出设置页面。  
点击红框内的新建,添加java的环境变量JAVA_HOME,值就是安装的jdk位置; 
 
(不要设CLASSPATH!)
接着找到名为Path的环境变量,点击编辑,然后添加一条新的路径%JAVA_HOME%\bin
使用变量的方式添加这条路径,好处是将来升级jdk或者重新安装的目录改变了,只需要更改对应的JAVA_HOME的
变量值就可以了。 
一路确定保存完毕后,就可以调出命令行工具来验证是否安装成功了。
输入命令java ­version,如果打印了java的版本信息说明安装成功。
 
部分系统可能需要注销或者重启才能生效。 
3. 安装命令行开发工具(ant/maven/gradle/git)  
maven 安装
 
安装maven这些工具的思路都是一样的,非常简单。首先下载对应的安装包,解压到某目录,并记住它们。
 
然后按照之前的办法添加环境变量,把各自的安装目录新建成对应的XXX_HOME变量,再把其下的bin目录加入
Path里,确认保存。 
调出命令行验证。
mvn ­v
ant ­v
gradle ­v
输出版本信息则安装成功。 
Git 客户端安装
 
Git的安装更加简单,下载安装程序以后,一路默认下一步完成即可。
  
  
  
  
  
 
在开始菜单找到git bash调出git命令行工具,输入git ­­version验证。 
 
 4. 安装和配置IDE
 
我们一般使用STS,其实就是Eclipse,不过已经把spring的相关功能整合好了。直接下载解压,找到最新的release
版本,里面的STS.exe文件直接运行即可。
启动过程选取一个喜欢的文件夹作为工作空间,这样IDE工具就启动好了。在用它开发项目之前,我们需要提前进
行一些设置。
基本都是在Preference下完成,所以要记住它的位置。菜单栏的Window­Preference即可调出。
按照下列截图进行配置。
       。
最后,如果频繁遇到sts运行过慢的问题,可以去找到同目录下的sts.ini文件,调整里面限制使用内存的参数。
­Xms512m
­Xmx768m
红色部分的数字就代表最小和最大内存占用,调大后可改善卡顿情况。
 
5. GitHub账号申请与使用  
注册  
登录GitHub官网,点击Sign up注册。 
免费仓库 
可以选填,也可以直接跳过
 
如果读得懂英文可以直接点击阅读指导手册,按照指导步骤熟悉git的线上操作。 
开启第一个仓库
 
直接点击start a Project
 
初始化页面介绍
  
点击README文件,可以在线编辑。
 
 
保存提交时必须额外写明一条说明,一般简单说一下修改内容或结果即可。 
这样就直接提交到了主分支。
这步选择Create a new branch for ...则会创建新的分支。
  
这样改变就添加入了新分支里,主分支master里的内容维持不变。
创建分支
也可以直接在此处创建分支,输入分支的名字就会出现创建的按钮,点击即可。
  
合并分支
 
给新分支的README添加一些修改,然后把新分支融入主分支master。
首先提出拉拖请求。
 
选择要融合的分支进行对比,如果结果无误则建立新的拉拖请求。
出现无法自动融合的警告也没关系,冲突会在随后解决。 
现在可以在pull requests里看到我们新提出的请求了。如果没有冲突,可以直接融合。
 
解决合并冲突
我们来看有冲突该怎么解决。点击Resolve Conflicts
  
Git将文件在两个分支的不同标注如图。
 
留下想要的部分,删除其他多余的内容即可。点击mark as resolved保存。
 
出现了Resolved all conflicts后,点击commit merge
 
现在点击Merge pull request进行融合。 
 
成功后显示如图,pull request自动关闭。
 
现在去检查主分支的内容,和teach­eg分支一致了。 
 
 
6. Git基本操作  
简介  
主要分为本地仓库管理和远程仓库管理两部分。
先讲一下本地仓库的管理,由已经安装的Git Bash操作。
Git的基本概念如下图,在仓库的目录下,用户自己的操作都归为workspace空间,所有的修改先要提交给
index(stage),然后再通过一条说明性质的message将这些修改一次性记录进本地仓库local repo,HEAD指向了
当前的本地仓库版本。 
有了这样一个总体的概念,接下来实际体会一下。
首先创建一个仓库。打开git bash,使用以下命令新建仓库的文件夹并初始化,得到一个主分支(master)。
 
然后在文件夹里出现了一个.git文件夹,所有git相关的记录都存在此处。
 
在仓库里加一些文件,比如一个txt文本文件README.txt,内容随便写点什么,比如“Hello, world!”,保存。 
命令行  
状态查看  
这时候再去git bash,通过"git status"可以查看WorkSpace的状态。
 
Git发现了README.txt的改变,但是它并没有被记录下来,输出信息提示可以通过“git add”命令把它加进等待提交的
stage区,使用效果如下。
 这条改变添加进了stage区,但是此时仍然没有被记录,如果还有其他改变可以一一加进来,最后需要进行commit
操作才能真正提交给本地仓库。输出也提示了如果想要撤销可以使用对应的git rm ­­cached命令。
最后用“git commit ­m”命令提交更新。
 
第一次身份配置
 
此时如果是第一次提交,git会提示不知道你的身份,需要使用“git config ­­global user.email”和“git config ­­
global user.name”设定自己的用户名和邮箱。
 
如果文件内容发生了改变,也是一样的流程记录进仓库。 
 
回退
从stage退回workspace的命令:reset HEAD
  
 
从本地仓库回退:先通过“git log”查看commit的历史记录。 
Commit后面跟着每次提交的commit id,使用它可以回退到当时的版本。命令是:
git reset ­­hard 
 
此时可以看到README文件已经变回了最开始的内容。
如果想要再回到最新的提交,也只要用同样的命令跳到最新提交的commit id即可。
 
如果觉得麻烦,在退回操作的时候也可以使用“HEAD^”代表上一个版本,“HEAD^^”代表上上个版本,上N个版本可
以直接使用“HEAD~N”来表示。 
把本地仓库提交到线上。
 
 
打标签,通常用来发布版本。
 
 
查看当前分支下的版本。
 
 
也可以给某次提交打tag
  
使用git checkout 查看该标签下的文件。此时处于一个空分支上,任何改变和提交都在这个独立的分支进行,但tag
本质是一个快照,不能提交修改,想要保存修改的话需要使用git chechout ­b 命令来创建新分支,然后就可以按照
一般分支的操作进行修改提交了。使用git checkout master回到主分支。
 
 
 
使用 git show < tagname >查看该版本的信息。
  
最后需要把tag提交到远程仓库。
 
git push origin 、
 
 
图形化界面操作介绍
 
接下来是在STS里使用git,其实这个才是我们平时使用最频繁的场景。
私钥配置
 引入一个远程项目前,首先需要设置自己的ssh密钥。仍然是Windows菜单下的preferences里,搜索ssh2面板,在
key management标签下点击generate RSA key,生成ssh密钥,点击保存。
 
 
将其中的公钥文件传至刚刚注册的git账户里,就进行代码的远程版本控制管理了。
  
  
 
从git网站中引入我们刚才建立的项目。
在“clone or download”按钮处找到此项目的git地址,一般就是当前工程的网络地址加上。Git的后缀。不过最好从此
处复制提供的地址:https://github.com/teach­eg/hello1.git
右键包浏览器空白,import引入项目,选择git下的Projects from git,下一步,clone URI
  
将地址粘贴进来,后面行内容会自动生成,最后两行填入自己的git帐号和密码,下一步 
选择需要的分支,下一步,再下一步。 
选择import as general Project,下一步,完成 
这样一个新的git工程就被拉进我们的本地仓库了,工作空间里显示如下。
 
修改,并提交
接下来同样的尝试对它进行修改提交等操作,在STS里由于有图形化界面,就轻松许多。
先随便对README做一些修改。保存后可以在包浏览器里发现,修改过的文件前面多了个小尖角箭头。
  
右键­>Team­>add to Index.箭头变成了图标右下角的星号
 
这个时候右键­>Team­>commit.
观察四周的小面板,git的面板会在其中一个地方出现,为了方便操作可以把它拉大,如图。
 
左上角是没有加入stage的修改,左下角是加入index的变化,右边框用于填写提交信息。
如果点击commit,改变就提交到了本地仓库,但是远程不会变化,commit and push才会一起提交到本地和远程仓
库。不过push也可以在commit之后单独进行。
提交本地仓库后文件图标又恢复了原样,但是由于没有提交远程仓库,在项目名称后面的灰字里会出现一个向上的
小箭头,后面数字写着未提交远程的版本数。 
这次右键整个项目,Team里会出现push to upstream
 
如果用户有权限,则会出现成功的结果。此时线上的teach­eg分支出现了我们新修改的内容。 
如果线上发生了改变,本地需要更新代码,也很简单,右键项目Team里的pull即可。 
  
解决冲突
 
那么,如果线上的代码发生了变化,我们本地也对同样的部分进行了修改,这样无论提交还是拉取都会产生冲突,
该怎么办呢?
我们同时对README进行不同的修改如图。
 
 
此时如果想要拉取代码,会提示README文件有冲突。 
需要先解决此冲突。因为我们自己也改过文件,所以必须先把自己修改过的README提交到本地仓库。注意,此时
不能push到远程,也会报冲突错误。
 
提交到本地仓库即可,此时我们自身的改变已经记录到本地,所以可以拉取远程更新了。
 
Pull结果显示有冲突,没关系,我们可以解决它。
此时看包浏览器,有冲突的文件和工程图标上出现了非常醒目的红色菱形标志,提示你必须解决它。 
我们点进去,可以看到git已经帮我们整理好了冲突内容的对比。和网站上的操作类似,在git括起来的部分留下想要
的部分,其余全部删掉。
 
保存后将文件添加进index,红色菱形的标志就会变成星号,此时提交更改,就可以顺利提交给远程仓库了。
 
Commit message会自动生成融合分支等等。
 可以直接commit and push提交给远程。
 
 
7. Maven基础知识  
简介  
Maven是个项目构建管理工具。可以用来管理依赖并进行编译、打包、发布等一系列操作。
在一个maven管理的项目里,相关的配置信息都写在了一个叫做pom.xml的文件里。位置在工程目录的第一级目
录。
 
他可以把我们想要的依赖包自动下载到本地,并且添加进我们的工程里。
一般默认会下载到C:\Users\Administrator.m2\repository这样一个目录下,所有maven下载的包都在这里可以找到,
是我们的本地仓库。
maven央库配置配置
那么maven是从哪里下载这些包的呢?就是在所谓的远程仓库了。默认寻找依赖包的地方是maven的中央仓库,但
是受限于网速等原因,实际上大公司一般会搭建自己的Nexus仓库,在局域网内提供依赖包下载。这需要我们把自
己的仓库配置通过一个xml文件告诉STS,现在有一个写好的xml文件,我们把它配置进STS里。仍然是
preperences,找到maven下的user settings
  
把配置文件nexus.xml放进去,应用并关闭。这样就完成了。现在maven会从该文件配置的仓库下载依赖。
 
Maven工程的结构如图
 
所有的maven描述都在pom.xml里完成。一个最简单的POM至少需要长成这样。
1. 
2. 4.0.0
3. com.mycompany.app
4. my­app
5. 1
6. 
Modelversion要设置成4.0.0;groupId, artifactId, version三个部分构成了这个包独一无二的maven坐标。打包发布
后其他工程寻找它就依赖于这个坐标。
实际当然不可能只有这么简单,在project标签上还需要添加xml的命名空间等相关配置才能使用后续的maven的属性
标签。像这样。
 添加依赖
 
除此之外,在project两个标签对之间,我们往往会根据需要添加其他有用的属性标签。最主要的就是用于添加依赖
的    标签。
在一个 
 
 标签对里,可以添加任意我们想要的依赖。
比如我们需要在代码里用到一个com.fasterxml.jackson.databind.ObjectMapper的类,那么就需要把它所在的jar包
加入到工程依赖里。这时候我们只要去网上找到它的maven坐标,按照格式加进来即可。
搜索某个包的maven 写法
 
打开百度,输入这个类,再加个maven,出来第一条结果就可以用。
 
点进去,如果没有版本要求,我们可以随便选一个,比如最新的2.9.2。
 
点进去可以看到网站给出的maven坐标,复制红框圈起来的部分放进dependencies标签内即可。 
保存POM文件,STS就会立即开始下载这个依赖。
 
maven 的继承性
 
在左侧的包浏览器里可以看到maven dependencies里面多了新加入的依赖。
 
但是为什么除了databind以外,还多了annotations和core两个包呢?这就涉及到databind包本身的依赖了。我们在引databind包的时候,不止引用了它本身,maven还自动去引用了它所依赖的包,在这里就是annotations和
core两个包。如果两个包里还依赖了别的包,那maven就会一层层去下载它们。如果有重复的包,则会自动只保留
一个。
想要查看一个包的具体依赖关系,可以按住ctrl键点击该包的maven坐标,STS就会跳转到它的POM文件。比如这个
databind包,点进去以后在底部选择pom.xml标签,就能看到它的maven结构。
 
在这里我们可以找到dependencies标签对里的依赖,果然有core和annotations两个包。 
有人可能注意到,dependencies里还有一些junit4啊jsr这些依赖,但是为什么它们没有出现在maven自动引入的依
赖库里呢?因为他们都规定了一个scope属性,它的值是test,这样就规定了这个依赖的作用范围只适用于测试使
用。所以当我们引用它的时候,这些依赖都是不可见的,无需理会。
作用域scope
scope包含如下的取值:
    compile(编译范围)
    compile是默认的范围;如果没有提供一个范围,那该依赖的范围就是编译范围。编译范围依赖在所有的
classpath中可用,同时它们也会被打包。
    provided(已提供范围)
    provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用。例如,如果你开发了一个web应用,你可能
在编译classpath中需要可用的Servlet API来编译一个servlet,但是你不会想要在打包好的WAR中包含这个
Servlet API;这个Servlet APIJAR由你的应用服务器或者servlet容器提供。已提供范围的依赖在编译classpath(不
是运行时)可用。它们不是传递性的,也不会被打包。
     runtime(运行时范围)
    runtime依赖在运行和测试系统的时候需要,但在编译的时候不需要。比如,你可能在编译的时候只需要
JDBC API JAR,而只有在运行的时候才需要JDBC驱动实现。
    test(测试范围)
    test范围依赖 在一般的 编译和运行时都不需要,它们只有在测试编译和测试运行阶段可用。
    system(系统范围)
    system范围依赖与provided类似,但是你必须显式的提供一个对于本地系统中JAR文件的路径。这么做是为了允
许基于本地对象编译,而这些对象是系统类库的一部分。这样的构件应该是一直可用的,Maven也不会在仓库中去
寻找它。 如果你将一个依赖范围设置成系统范围,你必须同时提供一个systemPath元素 。注意该范围是不推荐使
用的(你应该一直尽量去从公共或定制的Maven仓库中引用依赖)
除了管理依赖,maven还有一个非常重要的功能,就是构建项目。Maven把执行不同的构建任务定义成不同的目标
和生命周期
构建的各个环节
 
    [1] 清理clean:将以前编译得到的旧文件class字节码文件删除
 
    [2] 编译compile:将java源程序编译成class字节码文件
 
    [3] 测试test:自动测试,自动调用junit程序
 
    [4] 报告report:测试程序执行的结果
 
    [5] 打包package:动态Web工程打War包,java工程打jar包
 
    [6] 安装install:Maven特定的概念­­­­­将打包得到的文件复制到“仓库”中的指定位置
 
    [7] 部署deploy:将动态Web工程生成的war包复制到Servlet容器下,使其可以运行
 
每个阶段如果不配置,maven会使用自己默认的一套插件来执行任务。
如果有特殊的配置,就要描述在标签对里。比如这两个例子。
  
在这个build标签对里,我们定义了compiler插件,在configuration属性里配置我们使用插件时的特殊配置,比如这
里我们规定编译源码和生成.class文件的JDK版本都是1.8,compilerArgument则是传给javac的参数,表示不要执行
注释处理。
具体的配置属性可以通过类似这样的命令查询:
maven 插件(一)
 
mvn compiler:help ­Ddetail ­Dgoal=compile
 
maven 插件(二)单元测试插件
 第二个surefire插件,用来执行junit测试单元的工具。
 
设置为true的skip属性在这里有详细介绍。用来彻底忽视单元测试步骤,maven不推荐,但是我们项目里需要用到,
所以不用虚,根据需要设置就行。
 
maven 插件(三)第三方包打成Maven包
那么这些是对maven已知的包进行引用,如果我们需要引用自己生成的包怎么办?或者是某个依赖不支持maven形
式的引用,又该怎么使maven统一管理他们呢?
这就是maven的install概念,通过maven install的操作,maven可以将特定的包加入本地仓库,这样就可以把它按照
一般的maven依赖进行处理,非常简单快捷。
想要执行install命令,必须在pom里定义好本工程的maven坐标
  
看上去就跟引了一个普通的依赖一样,但是它不包括在任何标签内,是groupId、artifactId和version都是第一级标
签,内容按照规范编写就行。
这样我们右键项目­Run as­Maven install就可以打包项目成对应名称的jar包。如果想要的是别的打包格式需要格外
用标签指定。
 
打包的结果就出现在target文件夹下,可以从包浏览器里直接看到。
 
如果我们需要部署的话就可以直接用这个包拷到tomcat上面部署了。这个时候本地仓库里也装载了这个包,我们可
以在其他需要依赖它的项目里使用刚才定义的maven坐标引用它。 
这样就省去了我们把依赖包一遍遍复制到各个需要的项目里这种繁琐的步骤。
【依赖冲突】
 
有的时候,当我们引用的两个依赖包都间接依赖了某个相同的依赖包,如果它们的版本刚好一致,那么maven就会
只留一个包;但是如果它们的版本不同,有些就会产生版本冲突。
要解决这个冲突,我们可以使用maven自带的一个命令,非常简单地就能列出项目的整个依赖树,冲突来源一目了
然。
mvn dependency:tree
在STS中右键项目­Run as­Maven build...
 
在目标Goals输入框里输入dependency:tree运行即可。 
最后输出一个这样的报告:
[INFO] ­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­
[INFO] Building teach­eg 0.0.1­SNAPSHOT
[INFO] ­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­
[INFO] 
[INFO] ­­­ maven­dependency­plugin:2.8:tree (default­cli) @ teach­eg ­­­
[INFO] cn.com.taiji:teach­eg:jar:0.0.1­SNAPSHOT
[INFO] +­ com.fasterxml.jackson.core:jackson­databind:jar:2.9.2:compile
[INFO] |  +­ com.fasterxml.jackson.core:jackson­annotations:jar:2.9.0:compile
[INFO] |  ­ com.fasterxml.jackson.core:jackson­core:jar:2.9.2:compile
[INFO] ­ junit:junit:jar:3.8.1:test
[INFO] ­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­
[INFO] BUILD SUCCESS
[INFO] ­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­
[INFO] Total time: 1.334 s
[INFO] Finished at: 2017­11­06T15:27:15+08:00
[INFO] Final Memory: 12M/238M[INFO] ­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­
 
那么可以看到每一个依赖和它间接依赖到的包,每行末尾还写明了依赖的作用范围,比如junit就只作用于test,一般
我们引用的包默认都是compile作用范围。这样一来,我们就可以根据冲突的错误信息去寻找冲突的包。
或者,我们也可以在Dependency Hierarchy视图里更清楚地看到。
 
在filter里输入搜索关键字,就能找到所有相关的包。
 
左边栏是依赖树,右边栏是实际引入的依赖包列表。非常清楚,一目了然。
这里我们注意一下log­only和lower­log包引用的slf4j­log4j12,括号里写着因与1.7.8
版本冲突而被忽略,右边的实际引入列表也只有1.7.8版本,说明它们被maven自动排除了,原因就是版本冲突。 
大多数情况下maven可以主动解决冲突,可以看出来并不是根据版本高低决定的。Maven解决冲突的原则很简单,
就是短路优先。谁最先被引用到,就保留哪个。也就是说越间接的包保留优先级越低,在优先级相同的情况下,最
先出现在pom文件里的包被保留。
那么问题来了,有时候我们需要的版本和maven自动处理的不一样,该怎么办?这时候我们就要把不需要的包
exclude排除掉。
首先在依赖层级界面只要右击我们不想要的包,选择exclude maven artifact... 即可把所有版本都排除掉。
 
 
这个操作对应在pom文本里就是在对应的依赖标签里添加属性。 
所以接着我们只要去掉我们想要的那个版本的exclusion属性即可,比如1.7.10,去掉log­only包的exclusions属性,
再回到Dependency Hierarchy页面就能清楚地看到只有1.7.10存在了。 
 
这样一来我们就可以在众多冲突的包里保留一个需要的版本,
 
 
 
 
 
